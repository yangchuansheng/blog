[{"content":"Envoy 通过查询文件或管理服务器来动态发现资源。这些发现服务及其相应的 API 被统称为 xDS。Envoy 通过订阅（subscription）方式来获取资源，如监控指定路径下的文件、启动 gRPC 流（streaming）或轮询 REST-JSON URL。后两种方式会发送 DiscoveryRequest 请求消息，发现的对应资源则包含在响应消息 DiscoveryResponse 中。下面，我们将具体讨论每种订阅类型。\n文件订阅 发现动态资源的最简单方式就是将其保存于文件，并将路径配置在 ConfigSource 中的 path 参数中。Envoy 使用 inotify（Mac OS X 上为 kqueue）来监控文件的变化，在文件被更新时，Envoy 读取保存的 DiscoveryResponse 数据进行解析，数据格式可以为二进制 protobuf、JSON、YAML 和协议文本等。\n译者注：core.ConfigSource 配置格式如下：\n1 2 3 4 5 { \u0026#34;path\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;api_config_source\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;ads\u0026#34;: \u0026#34;{...}\u0026#34; } 文件订阅方式可提供统计数据和日志信息，但是缺少 ACK/NACK 更新的机制。如果更新的配置被拒绝，xDS API 则继续使用最后一个有效配置。\nACK 在 TCP 连接中是数据包确认消息，在 TCP 连接中，数据接收端在接收到一个数据包的时候会立即发送一个 ACK 消息给发送端，通知已经接收到此数据包，然后发送端再继续发送下一个数据包。 NACK 与 ACK 刚好相反，在 UDP 通信中，数据接收端接收到数据包后是不需要通知发送端的，发送端始终不断的发送数据包而不关心对方是否正确收到，亦不关心所发生的数据包是否有序到达。只有在接收端意识到有某个或某几个数据包没有接收到的情况下才会构造一个 NACK 消息包发送给发送端。请求发送端重发丢失包。 比如接收端收到数据包 100， 101， 103，105，然后发现 102， 104 丢了，会构造一个 NACK 包发送给发送端。 gRPC 流式订阅 单例资源类型发现 每个 xDS API 可以单独配置 ApiConfigSource，指向对应的上游管理服务器的集群地址。每个 xDS 资源类型会启动一个独立的双向 gRPC 流（每个 xDS 资源类型对应的管理服务器可能不同）。API 交付方式采用最终一致性。可以参考后续聚合服务发现（ADS） 章节来了解必要的显式控制序列。\n译者注：core.ApiConfigSource 配置格式如下：\n1 2 3 4 5 6 7 { \u0026#34;api_type\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;cluster_names\u0026#34;: [], \u0026#34;grpc_services\u0026#34;: [], \u0026#34;refresh_delay\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;request_timeout\u0026#34;: \u0026#34;{...}\u0026#34; } 类型 URL 每个 xDS API 都与给定的资源类型一一对应。关系如下：\nLDS ： envoy.api.v2.Listener RDS : envoy.api.v2.RouteConfiguration CDS : envoy.api.v2.Cluster EDS ： envoy.api.v2.ClusterLoadAssignment SDS ：envoy.api.v2.Auth.Secret 类型 URL 的概念如下所示，其采用 type.googleapis.com/\u0026lt;resource type\u0026gt; 的形式，例如 CDS 对应于 type.googleapis.com/envoy.api.v2.Cluster。在 Envoy 发起的发现请求和管理服务器返回的发现响应中，都包括了资源类型 URL。\nACK/NACK 和版本 每个 Envoy 流以发送一个 DiscoveryRequest 开始，包括了列表订阅的资源、订阅资源对应的类型 URL、节点标识符和空的 version_info。EDS 请求示例如下：\n1 2 3 4 5 6 7 version_info: node: { id: envoy } resource_names: - foo - bar type_url: type.googleapis.com/envoy.api.v2.ClusterLoadAssignment response_nonce: 管理服务器可立刻或等待资源就绪时发送 DiscoveryResponse 作为响应，示例如下：\n1 2 3 4 5 6 version_info: X resources: - foo ClusterLoadAssignment proto encoding - bar ClusterLoadAssignment proto encoding type_url: type.googleapis.com/envoy.api.v2.ClusterLoadAssignment nonce: A Envoy 在处理 DiscoveryResponse 响应后，将通过流发送一个新的请求，请求包含应用成功的最后一个版本号和管理服务器提供的 nonce。如果本次更新已成功应用，则 version_info 的值设置为 X，如下序列图所示：\n*ack 更新* 在此序列图及后续章节中，将统一使用以下缩写格式：\nDiscoveryRequest ：(V=version_info，R=resource_names，N=response_nonce，T=type_url) DiscoveryResponse ： (V=version_info，R=resources，N=nonce，T=type_url) 在信息安全中，Nonce 是一个在加密通信只能使用一次的数字。在认证协议中，它往往是一个随机或伪随机数，以避免重放攻击。Nonce 也用于流密码以确保安全。如果需要使用相同的密钥加密一个以上的消息，就需要 Nonce 来确保不同的消息与该密钥加密的密钥流不同。（引用自维基百科）在本文中 nonce 是每次更新的数据包的唯一标识。\r有了版本（version_info）这个概念，就可以为 Envoy 和管理服务器共享当前应用配置，以及提供了通过 ACK/NACK 来进行配置更新的机制。如果 Envoy 拒绝了配置更新 X，则回复 error_detail 及前一个版本号，在本例中为空的初始版本号，error_detail 包含了有关错误的更加详细的信息：\n*nack 更新* 重新发送 DiscoveryRequest 后，API 更新可能会在新版本 Y 上成功应用：\n每个流都有自己的版本概念，但不同的资源类型不能共享资源版本。在不使用 ADS 的情况下，每个资源类型可能具有不同的版本，因为 Envoy API 允许不同的 EDS/RDS 资源配置指向不同的 ConfigSources。\n何时发送更新 管理服务器应该只向 Envoy 客户端发送上次 DiscoveryResponse 后更新过的资源。Envoy 则会根据接受或拒绝 DiscoveryResponse 的情况，立即回复包含 ACK/NACK 的 DiscoveryRequest 请求。如果管理服务器不等待更新完成，每次返回相同的资源结果集合，则会导致 Envoy 和管理服务器通讯效率大打折扣。\n在同一个流中，新的 DiscoveryRequests 将取代此前具有相同资源类型的 DiscoveryRequest 请求。这意味着管理服务器只需要响应给定资源类型最新的 DiscoveryRequest 请求即可。\n资源提示 DiscoveryRequest 中的 resource_names 信息作为资源提示出现。一些资源类型，例如 Cluster 和 Listener 将使用一个空的 resource_names，因为 Envoy 需要获取对应节点标识的管理服务器的所有 Cluster（CDS）和 Listener（LDS）。对于其他资源类型，如 RouteConfigurations（RDS）和 ClusterLoadAssignments（EDS），则遵循此前的 CDS/LDS 更新，Envoy 能够通过枚举这些资源找到明确的资源。\nLDS/CDS 资源提示信息将始终为空，并且期望管理服务器的每个响应都提供 LDS/CDS 资源的完整状态。不存在的 Listener 或 Cluster 将被删除。如果 RDS 或 EDS 更新中缺少请求的资源，Envoy 将保留此资源的最后已知值。管理服务器能够从 DiscoveryRequest 中的节点标识（node.id）推断出所有所需的 EDS/RDS 资源，在这种情况下，该提示信息可能被丢弃。从 Envoy 的资源角度来看，空的 EDS/RDS DiscoveryResponse 响应实际上表示一个空的资源。\n当 Listener 或 Cluster 被删除时，其对应的 EDS 和 RDS 资源也会在 Envoy 实例中被删除。为使 EDS 资源能被 Envoy 获取或跟踪，就必须存在已经应用过的 Cluster 定义（如通过 CDS 获取）。RDS 和 Listeners 之间存在类似的关系（如通过 LDS 获取）。\n对于 EDS/RDS ，Envoy 可以为每个给定类型的资源生成不同的流（如每个 ConfigSource 都有自己的上游管理服务器集群）或当指定资源类型的请求发送到同一个管理服务器的时候，允许将多个资源请求组合在一起发送。虽然可以单个实现，但管理服务器应具备为每个请求中的给定资源类型处理一个或多个 resource_names 的能力。下面的两个序列图都可用于获取两个 EDS 资源 {foo，bar}：\n资源更新 如上所述，Envoy 可能会更新 DiscoveryRequest 中出现的 resource_names 列表，其中 DiscoveryRequest 是用来 ACK/NACK 管理服务器的特定的 DiscoveryResponse 。此外，Envoy 后续可能会在给定的 version_info 上发送额外的 DiscoveryRequests ，以使用新的资源提示来更新管理服务器。\n例如，如果 Envoy 在 EDS 版本 X 时仅知道集群 foo，但在随后收到的 CDS 更新时额外获取了集群 bar ，它可能会为版本 X 发出额外的 DiscoveryRequest 请求，并将 {foo，bar} 作为请求的 resource_names。\n这里可能会出现竞争状况；如果 Envoy 在版本 X 上发布了资源提示更新请求，但在管理服务器处理该请求之前发送了新的版本号为 Y 的响应，针对 version_info 为 X 的版本，资源提示更新可能会被解释为拒绝 Y 。为避免这种情况，通过使用管理服务器提供的 nonce，Envoy 可用来保证每个 DiscoveryRequest 对应到相应的 DiscoveryResponse：\n管理服务器不应该为含有过期 nonce 的 DiscoveryRequest 发送 DiscoveryResponse 响应。如果向 Envoy 发送的 DiscoveryResponse 中包含了的新 nonce，则此前的 nonce 将过期。在确定新版本可用之前，管理服务器不需要向 Envoy 发送更新。同版本的早期请求将会过期。在新版本就绪时，管理服务器可能会处理同一个版本号的多个 DiscoveryRequests 请求。\n上述资源更新序列表明 Envoy 并不能期待其发出的每个 DiscoveryRequest 都得到 DiscoveryResponse 响应。\n最终一致性考虑 由于 Envoy 的 xDS API 采用最终一致性，因此在更新期间可能导致流量被丢弃。例如，如果通过 CDS/EDS 仅获取到了集群 X，而且 RouteConfiguration 引用了集群 X；在 CDS/EDS 更新集群 Y 配置之前，如果将 RouteConfiguration 将引用的集群调整为 Y ，那么流量将被吸入黑洞而丢弃，直至集群 Y 被 Envoy 实例获取。\n对某些应用程序，可接受临时的流量丢弃，客户端或其他 Envoy sidecar 的重试可以解决该问题，并不影响业务逻辑。那些对流量丢弃不能容忍的场景，可以通过以下方式避免流量丢失，CDS/EDS 更新同时携带 X 和 Y ，然后发送 RDS 更新从 X 切换到 Y ，此后发送丢弃 X 的 CDS/EDS 更新。\n一般来说，为避免流量丢弃，更新的顺序应该遵循 make before break 模型，其中：\nCDS 首先更新 Cluster 数据（如果有变化） EDS 更新相应 Cluster 的 Endpoint 信息（如果有变化） LDS 更新 CDS/EDS 相应的 Listener RDS 最后更新新增 Listener 相关的 Route 配置 删除不再使用的 CDS cluster 和 EDS endpoints（不再被引用的 endpoint） 如果没有添加新的集群/路由/监听器，或者在更新期间暂时丢弃流量，则可以独立推送 xDS 更新。请注意，在 LDS 更新的情况下，监听器须在接收流量之前被预热，例如如其配置了依赖的路由，则需要先从 RDS 中获取。添加/删除/更新集群信息时，集群也需要进行预热。另一方面，如果管理平面确保路由更新时所引用的集群已经准备就绪，则路由可以不用预热。\n聚合服务发现（ADS） 当管理服务器进行资源分发时，通过上述保证交互顺序的方式来避免流量被丢弃是一项很有挑战的工作。ADS 允许单一管理服务器通过单个 gRPC 流来提供所有的 API 更新。配合仔细规划的更新顺序，ADS 可规避更新过程中的流量丢失。使用 ADS，在单个流上可通过类型 URL 来进行复用多个独立的 DiscoveryRequest/DiscoveryResponse 序列。对于任何给定类型的 URL，以上 DiscoveryRequest 和 DiscoveryResponse 消息序列都适用。 更新序列可能如下所示：\n每个 Envoy 实例可使用单独的 ADS 流。\n最小化 ADS 配置的 bootstrap.yaml 片段示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 node: id: \u0026lt;node identifier\u0026gt; dynamic_resources: cds_config: {ads: {}} lds_config: {ads: {}} ads_config: api_type: GRPC grpc_services: envoy_grpc: cluster_name: ads_cluster static_resources: clusters: - name: ads_cluster connect_timeout: { seconds: 5 } type: STATIC hosts: - socket_address: address: \u0026lt;ADS management server IP address\u0026gt; port_value: \u0026lt;ADS management server port\u0026gt; lb_policy: ROUND_ROBIN http2_protocol_options: {} admin: ... 增量 xDS 增量 xDS 是可用于 ADS、CDS 和 RDS 的单独 xDS 端点，允许以下操作：\nxDS 客户端对跟踪资源列表进行增量更新。这支持 Envoy 按需/惰性地请求额外资源（例如，当与未知集群相对应的请求到达时）。 xDS 服务器可以增量更新客户端上的资源。这可以实现 xDS 资源可伸缩性的目标。管理服务器只需交付更改的单个集群，而不是在修改单个集群时交付所有上万个集群。 xDS 增量 session 始终位于 gRPC 双向流的上下文中。这允许 xDS 服务器能够跟踪到连接的 xDS 客户端的状态。xDS REST 版本（v1）不支持增量。在增量 xDS 中，nonce 字段是必需的，用于将 IncrementalDiscoveryResponse 与关联的 ACK 或 NACK IncrementalDiscoveryRequest 进行匹配。IncrementalDiscoveryResponse 中的响应消息级别（system_version_info）仅用于调试目的。\nIncrementalDiscoveryRequest 可在以下 3 种情况下发送：\nxDS 双向 gRPC 流的初始消息。 作为对先前的 IncrementalDiscoveryResponse 的 ACK 或 NACK 响应。在这种情况下，response_nonce 被设置为响应中的 nonce 值。到底是 ACK 还是 NACK 可由 error_detail 字段是否出现来区分。 客户端自发的 IncrementalDiscoveryRequest。此场景下可以从跟踪的 resource_names 集合中动态添加或删除元素。此时必须忽略 response_nonce。 在下面的示例中，客户端连接并接收它的第一个更新并 ACK。第二次更新失败，客户端发送 NACK 拒绝更新。xDS客户端后续会自发地请求 wc 相关资源。\n在下面的示例中，当 xDS 客户端断开重新连接时，支持增量的 xDS 客户端可能会告诉服务器其已经获取的资源从而避免服务端通过网络重新发送它们。\nREST-JSON 轮询订阅 单个 xDS API 可以通过 REST 端点进行同步（长）轮询。除了无持久流与管理服务器交互外，消息交互顺序与上述两个订阅方式相似。在任何时间点，只存在一个未完成的请求，因此响应消息中的 nonce 在 REST-JSON 中是可选的。DiscoveryRequest 和 DiscoveryResponse 的消息编码遵循 JSON 变换 proto3 规范。ADS 不支持 REST-JSON 轮询订阅。\n当轮询周期设置为较小的值时，为了进行长轮询，这时要求避免发送 DiscoveryResponse，除非发生了对请求的资源的更改。\n参考资料 http://www.servicemesher.com/blog/envoy-xds-protocol/ https://github.com/envoyproxy/data-plane-api/blob/master/XDS_PROTOCOL.md ","description":"通过示例详解 Envoy 的 xDS REST 和 gRPC 协议。","id":0,"section":"docs","tags":null,"title":"xDS REST 和 gRPC 协议详解","uri":"https://fuckcloudnative.io/envoy-handbook/docs/basics/envoy-xds-protocol/"},{"content":"GetEnvoy Envoy 本身是很难编译的，需要使用到项目构建工具 Bazel，为了解决这个问题，Tetrate 的工程师（包括 Envoy 的核心贡献者和维护者）发起了 GetEnvoy 项目，目标是利用一套经过验证的构建工具来构建 Envoy，并通过常用的软件包管理器来分发，包括：apt、yum 和 Homebrew。安装方式如下：\nMacOS CentOS Ubuntu 1 2 3 4 5 6 7 8 9 10 11 $ brew update $ brew install envoy ==\u0026gt; Installing envoy ==\u0026gt; Downloading https://ghcr.io/v2/homebrew/core/envoy/manifests/1.18.3-1 ######################################################################## 100.0% ==\u0026gt; Downloading https://ghcr.io/v2/homebrew/core/envoy/blobs/sha256:d03fb86b48336c8d3c0f3711cfc3df3557f9fb33c966ceb1caecae1653935e90 ######################################################################## 100.0% ==\u0026gt; Pouring envoy--1.18.3.big_sur.bottle.1.tar.gz 🍺 /usr/local/Cellar/envoy/1.18.3: 300 files, 119.5MB 1 2 3 4 5 6 # 安装 yum-config-manager $ yum install -y yum-utils # 添加 Envoy 仓库 $ yum-config-manager --add-repo https://getenvoy.io/linux/centos/tetrate-getenvoy.repo # 安装 Envoy $ yum install -y getenvoy-envoy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 更新 apt 索引 $ apt update # 安装 HTTPS 依赖 $ apt install -y \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg2 \\ software-properties-common # 添加 Tetrate GPG 密钥 $ curl -sL \u0026#39;https://getenvoy.io/gpg\u0026#39; | sudo apt-key add - # 通过指纹验证密钥 $ apt-key fingerprint 6FF974DB | grep \u0026#34;5270 CEAC\u0026#34; pub 4096R/6FF974DB 2019-03-01 Key fingerprint = 5270 CEAC 57F6 3EBD 9EA9 005D 0253 D0B2 6FF9 74DB uid GetEnvoy \u0026lt;getenvoy@tetrate.io\u0026gt; sub 4096R/7767A960 2019-03-01 # 添加仓库 $ add-apt-repository \\ \u0026#34;deb [arch=amd64] https://dl.bintray.com/tetrate/getenvoy-deb \\ $(lsb_release -cs) \\ stable\u0026#34; # 安装 Envoy $ apt update \u0026amp;\u0026amp; apt install -y getenvoy-envoy Docker Envoy 社区不提供已经编译好的二进制的文件，只提供了 Docker 镜像（当然现在有 GetEnvoy 项目了）。社区提供的镜像位于 envoyproxy 中，常用的有：\nenvoyproxy/envoy-alpine : 基于 alpine 的发行镜像 envoyproxy/envoy-alpine-dev : 基于 alpine 的 Nightly 版本发行镜像 envoyproxy/envoy : 基于 Ubuntu 的发行镜像 envoyproxy/envoy-dev : 基于 Ubuntu 的 Nightly 版本发行镜像 获取镜像：\n1 $ docker pull envoyproxy/envoy:v1.18.3 启动 Envoy 容器时，可以用本地的 envoy.yaml 覆盖镜像中的 envoy.yaml：\n1 🐳 → docker run -d --network=host -v `pwd`/envoy.yaml:/etc/envoy/envoy.yaml envoyproxy/envoy:v1.18.3 Windows Envoy 官方还提供了 Windows 平台的 Docker 镜像，使用方式很简单：\n1 2 $ docker pull envoyproxy/envoy-windows-dev:latest $ docker run --rm envoyproxy/envoy-windows-dev:latest --version 参考资料 Installing Envoy ","description":"本文介绍了如何使用 GetEnvoy 项目和 Docker 来安装 Envoy。","id":1,"section":"docs","tags":null,"title":"安装","uri":"https://fuckcloudnative.io/envoy-handbook/docs/gettingstarted/setup/"},{"content":"本章节主题是如何从 Nginx 迁移到 Envoy Proxy，你可以将任何以前的经验和对 Nginx 的理解直接应用于 Envoy Proxy 中。\n主要内容：\n配置 Envoy Proxy 的 server 配置项 配置 Envoy Proxy 以将流量代理到外部服务 配置访问日志和错误日志 学完本教程之后，你将会了解 Envoy Proxy 的核心功能，以及如何将现有的 Nginx 配置文件迁移到 Envoy Proxy 中。\nNginx 与 Envoy Proxy 的核心模块 先来看一个 Nginx 配置文件的完整示例，该配置文件取自于 Nginx wiki，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 $ cat nginx.conf user www www; pid /var/run/nginx.pid; worker_processes 2; events { worker_connections 2000; } http { gzip on; gzip_min_length 1100; gzip_buffers 4 8k; gzip_types text/plain; log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#39; \u0026#39;\u0026#34;$request\u0026#34; $status $bytes_sent \u0026#39; \u0026#39;\u0026#34;$http_referer\u0026#34; \u0026#34;$http_user_agent\u0026#34; \u0026#39; \u0026#39;\u0026#34;$gzip_ratio\u0026#34;\u0026#39;; log_format download \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#39; \u0026#39;\u0026#34;$request\u0026#34; $status $bytes_sent \u0026#39; \u0026#39;\u0026#34;$http_referer\u0026#34; \u0026#34;$http_user_agent\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_range\u0026#34; \u0026#34;$sent_http_content_range\u0026#34;\u0026#39;; upstream targetCluster { 172.18.0.3:80; 172.18.0.4:80; } server { listen 8080; server_name one.example.com www.one.example.com; access_log /var/log/nginx.access_log main; error_log /var/log/nginx.error_log info; location / { proxy_pass http://targetCluster/; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } } Nginx 的配置通常分为三个关键要素：\n配置 Server 块、日志和 gzip 功能，这些配置对全局生效，可以应用于所有示例。 配置 Nginx 以接收 8080 端口上对域名 one.example.com 的访问请求。 将 URL 的不同路径的流量转发到不同的目标后端。 并不是所有的 Nginx 配置项都适用于 Envoy Proxy，其中有一些配置在 Envoy 中可以忽略。Envoy Proxy 有四个关键组件，可以用来匹配 Nginx 的核心配置块：\n监听器（Listener）：监听器定义了 Envoy 如何处理入站请求，目前 Envoy 仅支持基于 TCP 的监听器。一旦建立连接之后，就会将该请求传递给一组过滤器（filter）进行处理。 过滤器（Filter）：过滤器是处理入站和出站流量的链式结构的一部分。在过滤器链上可以集成很多特定功能的过滤器，例如，通过集成 GZip 过滤器可以在数据发送到客户端之前压缩数据。 路由（Router）：路由用来将流量转发到具体的目标实例，目标实例在 Envoy 中被定义为集群。 集群（Cluster）：集群定义了流量的目标端点，同时还包括一些其他可选配置，如负载均衡策略等。 接下来我们将使用这四个关键组件创建一个 Envoy Proxy 配置文件，以匹配前面定义的 Nginx 配置文件。\nNginx 配置迁移 Nginx 配置文件的第一部分定义了 Nginx 本身运行的工作特性。\nWorker 连接数 下面的配置定义了 Nginx 的 worker 进程数和最大连接数，这表明了 Nginx 是如何通过自身的弹性能力来满足各种需求的。\n1 2 3 4 5 worker_processes 2; events { worker_connections 2000; } 而 Envoy Proxy 则以不同的方式来管理 Worker 进程和连接。默认情况下，Envoy 为系统中的每个硬件线程生成一个工作线程。（可以通过 --concurrency 选项控制）。每个 Worker 线程是一个“非阻塞”事件循环，负责监听每个侦听器，接受新连接，为每个连接实例化过滤器栈，以及处理所有连接生命周期内 IO 事件。所有进一步的处理都在 Worker 线程内完成，其中包括转发。\nEnvoy 中的所有连接池都和 Worker 线程绑定。 尽管 HTTP/2 连接池一次只与每个上游主机建立一个连接，但如果有四个 Worker，则每个上游主机在稳定状态下将有四个 HTTP/2 连接。Envoy 以这种方式工作的原因是将所有连接都在单个 Worker 线程中处理，这样几乎所有代码都可以在无锁的情况下编写，就像它是单线程一样。拥有太多的 Worker 将浪费内存，创建更多空闲连接，并导致连接池命中率降低。\n你可以在 Envoy Proxy 博客上找到更多信息。\nHTTP 配置 Nginx 的下一个配置块是 HTTP 块，包括资源的媒体类型（mime type）、默认超时和 gzip 压缩配置。这些功能在 Envoy Proxy 中都是通过过滤器来实现的，下文将会详细讨论。\nServer 配置迁移 在 HTTP 配置块中，Nginx 配置指定了监听 8080 端口并接收对域名 one.example.com 和 www.one.example.com 的访问请求。\n1 2 3 server { listen 80; server_name one.example.com www.one.example.com; 这部分配置在 Envoy 中是由 Listener 管理的。\nEnvoy 监听器 让 Envoy 能正常工作最重要的一步是定义监听器。首先需要创建一个配置文件用来描述 Envoy 的运行参数。\n下面的配置项将创建一个新的监听器并将其绑定到 8080 端口。\n1 2 3 4 5 static_resources: listeners: - name: listener_0 address: socket_address: { address: 0.0.0.0, port_value: 8080 } 这里不需要定义 server_name，域名将会交给过滤器来处理。\nLocation 配置迁移 当请求进入 Nginx 时，Location 块定义了如何处理流量的元数据，以及如何转发处理后的流量。在下面的配置项中，进入站点的所有流量都被代理到名为 targetCluster 的上游集群。上游集群定了用来接收流量的后端实例，下一节再详细讨论。\n1 2 3 4 5 6 7 location / { proxy_pass http://targetCluster/; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } 这部分配置在 Envoy 中是由过滤器管理的。\nEnvoy 过滤器 对于静态配置文件而言，过滤器定义了如何处理传入请求。这里我们将会创建一个与上一节 Nginx 配置中的 server_names 相匹配的过滤器，当收到与过滤器中定义的域名和路由相匹配的入站请求时，就会将该请求的流量转发到指定的集群。这里的集群相当于 Nginx 中的 upstream 配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 filter_chains: - filters: - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http route_config: name: local_route virtual_hosts: - name: backend domains: - \u0026#34;one.example.com\u0026#34; - \u0026#34;www.one.example.com\u0026#34; routes: - match: prefix: \u0026#34;/\u0026#34; route: cluster: targetCluster http_filters: - name: envoy.router envoy.http_connection_manager 是 Envoy 中的内置 HTTP 过滤器。除了该过滤器，Envoy 中还内置了一些其他过滤器，包括 Redis、Mongo、TCP 等，完整的过滤器列表请参考 Envoy 官方文档。\nProxy 与 upstream 配置迁移 在 Nginx 中，upstream 配置项定义了用来接收流量的目标服务集群。下面的 upstream 配置项分配了两个后端实例：\n1 2 3 4 upstream targetCluster { 172.18.0.3:80; 172.18.0.4:80; } 这部分配置在 Envoy 中是由集群（Cluster）管理的。\nEnvoy 集群 upstream 配置项在 Envoy 中被定义为 Cluster。Cluster 中的 hosts 列表用来处理被过滤器转发的流量，其中 hosts 的访问策略（例如超时）也在 Cluster 中进行配置，这有利于更精细化地控制超时和负载均衡。\n1 2 3 4 5 6 7 8 9 10 clusters: - name: targetCluster connect_timeout: 0.25s type: STRICT_DNS dns_lookup_family: V4_ONLY lb_policy: ROUND_ROBIN hosts: [ { socket_address: { address: 172.18.0.3, port_value: 80 }}, { socket_address: { address: 172.18.0.4, port_value: 80 }} ] 当使用 STRICT_DNS 类型的服务发现时，Envoy 将持续并异步地解析指定的 DNS 目标。DNS 结果中每个返回的 IP 地址将被视为上游集群中的显式主机。这意味着如果查询返回三个 IP 地址，Envoy 将假定该集群有三台主机，并且所有三台主机应该负载均衡。如果有主机从 DNS 返回结果中删除，则 Envoy 会认为它不再存在，并且会将它从所有的当前连接池中排除。更多详细内容请参考 Envoy 官方文档。\n日志配置迁移 最后一部分需要迁移的配置是应用日志。Envoy Proxy 默认情况下没有将日志持久化到磁盘中，而是遵循云原生方法，其中所有应用程序日志都输出到 stdout 和 stderr。\n关于用户请求信息的访问日志属于可选项，默认情况下是禁用的。要为 HTTP 请求启用访问日志，请在 envoy.http_connection_manager 过滤器中添加 access_log 配置项，日志路径可以是块设备（如 stdout），也可以是磁盘上的文件，具体取决于你的需求。\n下面的配置项将所有的访问日志传递给 stdout：\n1 2 3 4 access_log: - name: envoy.file_access_log config: path: \u0026#34;/dev/stdout\u0026#34; 将该配置项复制到 envoy.http_connection_manager 过滤器的配置中，完整的过滤器配置如下：\n1 2 3 4 5 6 7 8 9 - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http access_log: - name: envoy.file_access_log config: path: \u0026#34;/dev/stdout\u0026#34; route_config: Envoy 默认情况下使用格式化字符串来输出 HTTP 请求的详细日志：\n1 2 3 4 [%START_TIME%] \u0026#34;%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%\u0026#34; %RESPONSE_CODE% %RESPONSE_FLAGS% %BYTES_RECEIVED% %BYTES_SENT% %DURATION% %RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% \u0026#34;%REQ(X-FORWARDED-FOR)%\u0026#34; \u0026#34;%REQ(USER-AGENT)%\u0026#34; \u0026#34;%REQ(X-REQUEST-ID)%\u0026#34; \u0026#34;%REQ(:AUTHORITY)%\u0026#34; \u0026#34;%UPSTREAM_HOST%\u0026#34;\\n 本示例中的日志输出如下所示：\n1 [2018-11-23T04:51:00.281Z] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - 0 58 4 1 \u0026#34;-\u0026#34; \u0026#34;curl/7.47.0\u0026#34; \u0026#34;f21ebd42-6770-4aa5-88d4-e56118165a7d\u0026#34; \u0026#34;one.example.com\u0026#34; \u0026#34;172.18.0.4:80\u0026#34; 可以通过设置格式化字段来自定义日志输出内容，例如：\n1 2 3 4 5 access_log: - name: envoy.file_access_log config: path: \u0026#34;/dev/stdout\u0026#34; format: \u0026#34;[%START_TIME%] \u0026#34;%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%\u0026#34; %RESPONSE_CODE% %RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% \u0026#34;%REQ(X-REQUEST-ID)%\u0026#34; \u0026#34;%REQ(:AUTHORITY)%\u0026#34; \u0026#34;%UPSTREAM_HOST%\u0026#34;\\n\u0026#34; 你也可以通过设置 json_format 字段来输出 JSON 格式的日志，例如：\n1 2 3 4 5 access_log: - name: envoy.file_access_log config: path: \u0026#34;/dev/stdout\u0026#34; json_format: {\u0026#34;protocol\u0026#34;: \u0026#34;%PROTOCOL%\u0026#34;, \u0026#34;duration\u0026#34;: \u0026#34;%DURATION%\u0026#34;, \u0026#34;request_method\u0026#34;: \u0026#34;%REQ(:METHOD)%\u0026#34;} 关于 Envoy 日志配置的更多详细配置请参考 https://www.envoyproxy.io/docs/envoy/latest/configuration/access_log#config-access-log-format-dictionaries。\n在生产环境中使用 Envoy Proxy 时，日志不是获取可观察性的唯一方法，Envoy 中还内置了更高级的功能，如分布式追踪和监控指标。你可以在分布式追踪文档中找到更多详细内容。\n完整的 Envoy 配置文件如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 static_resources: listeners: - name: listener_0 address: socket_address: { address: 0.0.0.0, port_value: 8080 } filter_chains: - filters: - name: envoy.http_connection_manager config: codec_type: auto stat_prefix: ingress_http route_config: name: local_route virtual_hosts: - name: backend domains: - \u0026#34;one.example.com\u0026#34; - \u0026#34;www.one.example.com\u0026#34; routes: - match: prefix: \u0026#34;/\u0026#34; route: cluster: targetCluster http_filters: - name: envoy.router clusters: - name: targetCluster connect_timeout: 0.25s type: STRICT_DNS dns_lookup_family: V4_ONLY lb_policy: ROUND_ROBIN hosts: [ { socket_address: { address: 172.18.0.3, port_value: 80 }}, { socket_address: { address: 172.18.0.4, port_value: 80 }} ] admin: access_log_path: /tmp/admin_access.log address: socket_address: { address: 0.0.0.0, port_value: 9090 } 启动 Envoy Proxy 现在已经将 Nginx 的所有配置转化为 Envoy Proxy 的配置，接下来就是启动 Envoy 实例并进行测试。\n以普通用户身份运行 在 Nginx 配置文件的顶部有一行配置 user www www;，表示以低权限用户身份运行 Nginx 以提高安全性。而 Envoy 则采用云原生的方法来管理进程所有者，当我们通过容器来启动 Envoy Proxy 时，可以通过命令行参数来指定一个低权限用户。\n启动 Envoy Proxy 下面的命令将通过容器启动 Envoy Proxy，该命令将 Envoy 容器暴露在 80 端口上以监听入站请求，但容器内的 Envoy Proxy 监听在 8080 端口上。通过 --user 参数以允许进程以低权限用户身份运行。\n1 $ docker run --name proxy1 -p 80:8080 --user 1000:1000 -v /root/envoy.yaml:/etc/envoy/envoy.yaml envoyproxy/envoy 测试 启动代理之后，现在就可以进行访问测试了。下面的 curl 命令使用 Envoy 配置文件中定义的 请求头文件中的 Host 字段发出请求：\n1 $ curl -H \u0026#34;Host: one.example.com\u0026#34; localhost -i 如果不出意外，该请求将会返回 503 错误，因为上游集群还没有运行，处于不可用状态，Envoy Proxy 找不到可用的目标后端来处理该请求。下面就来启动相应的 HTTP 服务：\n1 2 $ docker run -d katacoda/docker-http-server $ docker run -d katacoda/docker-http-server 启动这些服务之后，Envoy 就可以成功将流量代理到目标后端：\n1 $ curl -H \u0026#34;Host: one.example.com\u0026#34; localhost -i 现在你应该会看到请求已被成功响应，并且可以从日志中看到哪个容器响应了该请求。\n附加的 HTTP 响应头文件 如果请求成功，你会在请求的响应头文件中看到一些附加的字段，这些字段包含了上游主机处理请求所花费的时间（以毫秒为单位）。如果客户端想要确定因为网络延迟导致的请求处理延时，这些字段将会很有帮助。\n1 2 x-envoy-upstream-service-time: 0 server: envoy ","description":"本章节将会带你了解 Envoy Proxy 的核心功能，以及如何将现有的 Nginx 配置文件迁移到 Envoy Proxy 中。","id":2,"section":"docs","tags":null,"title":"从 Nginx 迁移到 Envoy Proxy","uri":"https://fuckcloudnative.io/envoy-handbook/docs/practice/migrating-from-nginx-to-envoy/"},{"content":"Envoy 是专为大型现代 SOA（面向服务架构）架构设计的 L7 代理和通信总线，体积小，性能高。它的诞生源于以下理念：\n对应用程序而言，网络应该是透明的。当网络和应用程序出现故障时，应该能够很容易确定问题的根源。\n核心功能 实际上，实现上述的目标是非常困难的。为了做到这一点，Envoy 提供了以下高级功能：\n非侵入的架构 : Envoy 是一个独立进程，设计为伴随每个应用程序服务运行。所有的 Envoy 形成一个透明的通信网格，每个应用程序发送消息到本地主机或从本地主机接收消息，不需要知道网络拓扑，对服务的实现语言也完全无感知，这种模式也被称为 Sidecar。\n由 C++ 语言实现，拥有强大的定制化能力和优异的性能。\nL3/L4/L7 架构 : 传统的网络代理，要么在 HTTP 层工作，要么在 TCP 层工作。在 HTTP 层的话，你将会从传输线路上读取整个 HTTP 请求的数据，对它做解析，查看 HTTP 头部和 URL，并决定接下来要做什么。随后，你将从后端读取整个响应的数据，并将其发送给客户端。但这种做法的缺点就是非常复杂和缓慢，更好的选择是下沉到 TCP 层操作：只读取和写入字节，并使用 IP 地址，TCP 端口号等来决定如何处理事务，但无法根据不同的 URL 代理到不同的后端。Envoy 支持同时在 3/4 层和 7 层操作，以此应对这两种方法各自都有其实际限制的现实。\n顶级 HTTP/2 支持 : 它将 HTTP/2 视为一等公民，并且可以在 HTTP/2 和 HTTP/1.1 之间相互转换（双向），建议使用 HTTP/2。\n服务发现和动态配置 : 与 Nginx 等代理的热加载不同，Envoy 可以通过 API 来实现其控制平面，控制平面可以集中服务发现，并通过 API 接口动态更新数据平面的配置，不需要重启数据平面的代理。不仅如此，控制平面还可以通过 API 将配置进行分层，然后逐层更新，例如：上游集群中的虚拟主机、HTTP 路由、监听的套接字等。\ngRPC 支持 : gRPC 是一个来自 Google 的 RPC 框架，它使用 HTTP/2 作为底层多路复用传输协议。Envoy 完美支持 HTTP/2，也可以很方便地支持 gRPC。\n特殊协议支持 : Envoy 支持对特殊协议在 L7 进行嗅探和统计，包括：MongoDB、DynamoDB 等。\n可观测性 : Envoy 的主要目标是使网络透明，可以生成许多流量方面的统计数据，这是其它代理软件很难取代的地方，内置 stats 模块，可以集成诸如 prometheus/statsd 等监控方案。还可以集成分布式追踪系统，对请求进行追踪。\n设计目标 Envoy 官方的设计目标是这么说的：\nEnvoy 并不是很慢（我们已经花了相当长的时间来优化关键路径）。基于模块化编码，易于测试，而不是性能最优。我们的观点是，在其他语言或者运行效率低很多的系统中，部署和使用 Envoy 能够带来很好的运行效率。\r虽然 Envoy 没有把追求极致的性能作为首要目标，但并不表示 Envoy 是没有追求的，只是扩展性优先，性能稍微靠边。Envoy 和 Nginx 一样，也采用了 多线程 + 非阻塞 + 异步IO（Libevent） 的架构，性能仍然很强悍。\n参考资料 Envoy 是什么？ Lyft Envoy入门教程 ","description":"","id":3,"section":"docs","tags":null,"title":"Envoy 介绍","uri":"https://fuckcloudnative.io/envoy-handbook/docs/overview/overview/"},{"content":"监听器（Listener） 监听器（Listener）就是 Envoy 的监听地址，可以是端口或 Unix Socket。Envoy 在单个进程中支持任意数量的监听器。通常建议每台机器只运行一个 Envoy 实例，每个 Envoy 实例的监听器数量没有限制，这样可以简化操作，统计数据也只有一个来源，比较方便统计。目前 Envoy 支持监听 TCP 协议和 UDP 协议。\nTCP 每个监听器都可以配置多个过滤器链（Filter Chains），监听器会根据 filter_chain_match 中的匹配条件将流量转交到对应的过滤器链，其中每一个过滤器链都由一个或多个网络过滤器（Network filters）组成。这些过滤器用于执行不同的代理任务，如速率限制，TLS 客户端认证，HTTP 连接管理，MongoDB 嗅探，原始 TCP 代理等。\n除了过滤器链之外，还有一种过滤器叫监听器过滤器（Listener filters），它会在过滤器链之前执行，用于操纵连接的元数据。这样做的目的是，无需更改 Envoy 的核心代码就可以方便地集成更多功能。例如，当监听的地址协议是 UDP 时，就可以指定 UDP 监听器过滤器。\nUDP Envoy 的监听器也支持 UDP 协议，需要在监听器过滤器中指定一种 UDP 监听器过滤器（UDP listener filters）。目前有两种 UDP 监听器过滤器：UDP 代理（UDP proxy） 和 DNS 过滤器（DNSfilter）。UDP 监听器过滤器会被每个 worker 线程实例化，且全局生效。实际上，UDP 监听器（UDP Listener）配置了内核参数 SO_REUSEPORT，这样内核就会将 UDP 四元组相同的数据散列到同一个 worker 线程上。因此，UDP 监听器过滤器是允许面向会话（session）的。\n监听器配置结构 监听器的配置结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \u0026#34;name\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;filter_chains\u0026#34;: [], \u0026#34;per_connection_buffer_limit_bytes\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;metadata\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;drain_type\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;listener_filters\u0026#34;: [], \u0026#34;listener_filters_timeout\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;continue_on_listener_filters_timeout\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;transparent\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;freebind\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;socket_options\u0026#34;: [], \u0026#34;tcp_fast_open_queue_length\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;traffic_direction\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;udp_listener_config\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;api_listener\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;connection_balance_config\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;reuse_port\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;access_log\u0026#34;: [] } name : 监听器名称。默认情况下，监听器名称的最大长度限制为 60 个字符。可以通过 --max-obj-name-len 命令行参数设置为所需的最大长度限制。 address : 监听器的监听地址，支持网络 Socket 和 Unix Domain Socket（UDS） 两种类型。 filter_chains : 过滤器链的配置。 per_connection_buffer_limit_bytes : 监听器每个新连接读取和写入缓冲区大小的软限制。默认值是 1MB。 listener_filters : 监听器过滤器在过滤器链之前执行，用于操纵连接的元数据。这样做的目的是，无需更改 Envoy 的核心代码就可以方便地集成更多功能。例如，当监听的地址协议是 UDP 时，就可以指定 UDP 监听器过滤器。 listener_filters_timeout : 等待所有监听器过滤器完成操作的超时时间。一旦超时就会关闭 Socket，不会创建连接，除非将参数 continue_on_listener_filters_timeout 设为 true。默认超时时间是 15s，如果设为 0 则表示禁用超时功能。 continue_on_listener_filters_timeout : 布尔值。用来决定监听器过滤器处理超时后是否创建连接，默认为 false。 freebind : 布尔值。用来决定是否设置 Socket 的 IP_FREEBIND 选项。如果设置为 true，则允许监听器绑定到本地并不存在的 IP 地址上。默认不设置。 socket_options : 额外的 Socket 选项。 tcp_fast_open_queue_length : 控制 TCP 快速打开（TCP Fast Open，简称 TFO）。TFO 是对TCP 连接的一种简化握手手续的拓展，用于提高两端点间连接的打开速度。它通过握手开始时的 SYN 包中的 TFO cookie（一个 TCP 选项）来验证一个之前连接过的客户端。如果验证成功，它可以在三次握手最终的 ACK 包收到之前就开始发送数据，这样便跳过了一个绕路的行为，更在传输开始时就降低了延迟。该字段用来限制 TFO cookie 队列的长度，如果设为 0，则表示关闭 TFO。 traffic_direction : 定义流量的预期流向。有三个选项：UNSPECIFIED、INBOUND 和 OUTBOUND，分别代表未定义、入站流量和出站流量，默认是 UNSPECIFIED。 udp_listener_config : 如果 address 字段的类型是网络 Socket，且协议是 UDP，则使用该字段来指定 UDP 监听器。 connection_balance_config : 监听器连接的负载均衡配置，目前只支持 TCP。 reuse_port : 布尔值。用来决定是否设置 Socket 的 SO_REUSEPORT 选项。如果设置为 true，则会为每一个 worker 线程创建一个 Socket，在有大量连接的情况下，入站连接会均匀分布到各个 worker 线程中。如果设置为 false，所有的 worker 线程共享同一个 Socket。 access_log : 日志相关的配置。 ","description":"本章节描述了 Envoy 监听器的概念及其配置结构。","id":4,"section":"docs","tags":null,"title":"监听器","uri":"https://fuckcloudnative.io/envoy-handbook/docs/basics/listeners/"},{"content":"安装完成后，可以通过下面的例子快速体验 Envoy 的功能。\n本文的示例使用 Envoy 作为边缘代理，根据不同的路由配置将请求转发到百度和 Bing。指定请求头 host: baidu.com 时会将请求转发到 www.baidu.com；指定请求头 host: bing.com 时会将请求转发到 cn.bing.com。\n配置 Envoy 使用 YAMl 配置来控制代理的行为，为了快速开始，我们可以从 GetEnvoy 项目上下载静态配置的示例：\n1 $ wget https://getenvoy.io/samples/basic-front-proxy.yaml Envoy 代理使用开源 xDS API 来交换信息，目前 xDS v2 已被废弃，最新版本的 Envoy 不再支持 xDS v2，建议使用 xDS v3。\r由于国内不可描述的网络原因，最好将示例中的 google 改成 baidu，并将 xDS API 改为 v3，改完后完整的配置文件如下：\nbasic-front-proxy.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 static_resources: listeners: - address: # Tells Envoy to listen on 0.0.0.0:15001 socket_address: address: 0.0.0.0 port_value: 15001 filter_chains: # Any requests received on this address are sent through this chain of filters - filters: # If the request is HTTP it will pass through this HTTP filter - name: envoy.filters.network.http_connection_manager typed_config: \u0026#34;@type\u0026#34;: type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager codec_type: auto stat_prefix: http access_log: name: envoy.access_loggers.file typed_config: \u0026#34;@type\u0026#34;: type.googleapis.com/envoy.extensions.access_loggers.file.v3.FileAccessLog path: /dev/stdout route_config: name: search_route virtual_hosts: - name: backend domains: - \u0026#34;*\u0026#34; routes: # Match on host (:authority in HTTP2) headers - match: prefix: \u0026#34;/\u0026#34; headers: - name: \u0026#34;:authority\u0026#34; exact_match: \u0026#34;baidu.com\u0026#34; route: # Send request to an endpoint in the Google cluster cluster: baidu host_rewrite_literal: www.baidu.com - match: prefix: \u0026#34;/\u0026#34; headers: - name: \u0026#34;:authority\u0026#34; exact_match: \u0026#34;bing.com\u0026#34; route: # Send request to an endpoint in the Bing cluster cluster: bing host_rewrite_literal: cn.bing.com http_filters: - name: envoy.filters.http.router clusters: - name: baidu connect_timeout: 1s # Instruct Envoy to continouously resolve DNS of www.google.com asynchronously type: logical_dns dns_lookup_family: V4_ONLY lb_policy: round_robin load_assignment: cluster_name: baidu endpoints: - lb_endpoints: - endpoint: address: socket_address: address: www.baidu.com port_value: 80 - name: bing connect_timeout: 1s # Instruct Envoy to continouously resolve DNS of www.bing.com asynchronously type: logical_dns dns_lookup_family: V4_ONLY lb_policy: round_robin load_assignment: cluster_name: bing endpoints: - lb_endpoints: - endpoint: address: socket_address: address: cn.bing.com port_value: 80 admin: access_log_path: \u0026#34;/dev/stdout\u0026#34; address: socket_address: address: 0.0.0.0 port_value: 15000 第一次使用 Envoy，可能会觉得它的配置太复杂了，让人眼花缭乱。其实不然，我们不妨先脑补一下网络代理程序的流程，比如作为一个代理，首先要能获取请求流量，通常是采用监听端口的方式实现；其次拿到请求数据后需要对其做微处理，例如附加 Header 或校验某个 Header 字段的内容等，这里针对来源数据的层次不同，可以分为 L3/L4/L7，然后将请求转发出去；转发这里又可以衍生出如果后端是一个集群，需要从中挑选一台机器，如何挑选又涉及到负载均衡等。\n脑补完大致流程后，再来看 Envoy 是如何组织配置信息的，先简单解释一下其中的关键字段，详细的解释可以看后面的章节。\nlistener : Envoy 的监听地址，就是真正干活的。Envoy 会暴露一个或多个 Listener 来监听客户端的请求。 filter : 过滤器。在 Envoy 中指的是一些“可插拔”和可组合的逻辑处理层，是 Envoy 核心逻辑处理单元。 route_config : 路由规则配置。即将请求路由到后端的哪个集群。 cluster : 服务提供方集群。Envoy 通过服务发现定位集群成员并获取服务，具体路由到哪个集群成员由负载均衡策略决定。 结合关键字段和上面的脑补流程，可以看出 Envoy 的大致处理流程如下：\nEnvoy 内部对请求的处理流程其实跟我们上面脑补的流程大致相同，即对请求的处理流程基本是不变的，而对于变化的部分，即对请求数据的微处理，全部抽象为 Filter，例如对请求的读写是 ReadFilter、WriteFilter，对 HTTP 请求数据的编解码是 StreamEncoderFilter、StreamDecoderFilter，对 TCP 的处理是 TcpProxyFilter，其继承自 ReadFilter，对 HTTP 的处理是 ConnectionManager，其也是继承自 ReadFilter 等等，各个 Filter 最终会组织成一个 FilterChain，在收到请求后首先走 FilterChain，其次路由到指定集群并做负载均衡获取一个目标地址，然后转发出去。\n启动 Envoy 配置完成后，就可以通过静态配置文件直接启动 Envoy 了：\n1 $ envoy -c ./basic-front-proxy.yaml 打开一个新的 shell，使用 curl 访问 Envoy，并添加 Header 字段 host: baidu.com：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $ curl -s -o /dev/null -vvv -H \u0026#39;Host: baidu.com\u0026#39; 127.0.0.1:15001 * Rebuilt URL to: 127.0.0.1:15001/ * Trying 127.0.0.1... * TCP_NODELAY set * Connected to 127.0.0.1 (127.0.0.1) port 15001 (#0) \u0026gt; GET / HTTP/1.1 \u0026gt; Host: baidu.com \u0026gt; User-Agent: curl/7.54.0 \u0026gt; Accept: */* \u0026gt; \u0026lt; HTTP/1.1 200 OK \u0026lt; accept-ranges: bytes \u0026lt; cache-control: private, no-cache, no-store, proxy-revalidate, no-transform \u0026lt; content-length: 2381 \u0026lt; content-type: text/html \u0026lt; date: Sun, 03 May 2020 09:46:59 GMT \u0026lt; etag: \u0026#34;588604c8-94d\u0026#34; \u0026lt; last-modified: Mon, 23 Jan 2017 13:27:36 GMT \u0026lt; pragma: no-cache \u0026lt; server: envoy \u0026lt; set-cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/ \u0026lt; x-envoy-upstream-service-time: 19 \u0026lt; { [1048 bytes data] * Connection #0 to host 127.0.0.1 left intact 可以看到请求被转发到了 baidu.com，并且在转发的时候将 host 修改成了 www.baidu.com。访问时去掉参数 -s -o /dev/null 可以看到完整的响应内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 $ curl -vvv -H \u0026#39;Host: baidu.com\u0026#39; 127.0.0.1:15001 * Rebuilt URL to: 127.0.0.1:15001/ * Trying 127.0.0.1... * TCP_NODELAY set * Connected to 127.0.0.1 (127.0.0.1) port 15001 (#0) \u0026gt; GET / HTTP/1.1 \u0026gt; Host: baidu.com \u0026gt; User-Agent: curl/7.54.0 \u0026gt; Accept: */* \u0026gt; \u0026lt; HTTP/1.1 200 OK \u0026lt; accept-ranges: bytes \u0026lt; cache-control: private, no-cache, no-store, proxy-revalidate, no-transform \u0026lt; content-length: 2381 \u0026lt; content-type: text/html \u0026lt; date: Sun, 03 May 2020 09:50:07 GMT \u0026lt; etag: \u0026#34;588604c8-94d\u0026#34; \u0026lt; last-modified: Mon, 23 Jan 2017 13:27:36 GMT \u0026lt; pragma: no-cache \u0026lt; server: envoy \u0026lt; set-cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/ \u0026lt; x-envoy-upstream-service-time: 37 \u0026lt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;!--STATUS OK--\u0026gt;\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;meta http-equiv=content-type content=text/html;charset=utf-8\u0026gt;\u0026lt;meta http-equiv=X-UA-Compatible content=IE=Edge\u0026gt;\u0026lt;meta content=always name=referrer\u0026gt;\u0026lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css\u0026gt;\u0026lt;title\u0026gt;百度一下，你就知道\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body link=#0000cc\u0026gt; \u0026lt;div id=wrapper\u0026gt; \u0026lt;div id=head\u0026gt; \u0026lt;div class=head_wrapper\u0026gt; \u0026lt;div class=s_form\u0026gt; \u0026lt;div class=s_form_wrapper\u0026gt; \u0026lt;div id=lg\u0026gt; \u0026lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;form id=form name=f action=//www.baidu.com/s class=fm\u0026gt; \u0026lt;input type=hidden name=bdorz_come value=1\u0026gt; \u0026lt;input type=hidden name=ie value=utf-8\u0026gt; \u0026lt;input type=hidden name=f value=8\u0026gt; \u0026lt;input type=hidden name=rsv_bp value=1\u0026gt; \u0026lt;input type=hidden name=rsv_idx value=1\u0026gt; \u0026lt;input type=hidden name=tn value=baidu\u0026gt;\u0026lt;span class=\u0026#34;bg s_ipt_wr\u0026#34;\u0026gt;\u0026lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;bg s_btn_wr\u0026#34;\u0026gt;\u0026lt;input type=submit id=su value=百度一下 class=\u0026#34;bg s_btn\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=u1\u0026gt; \u0026lt;a href=http://news.baidu.com name=tj_trnews class=mnav\u0026gt;新闻\u0026lt;/a\u0026gt; \u0026lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav\u0026gt;hao123\u0026lt;/a\u0026gt; \u0026lt;a href=http://map.baidu.com name=tj_trmap class=mnav\u0026gt;地图\u0026lt;/a\u0026gt; \u0026lt;a href=http://v.baidu.com name=tj_trvideo class=mnav\u0026gt;视频\u0026lt;/a\u0026gt; \u0026lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav\u0026gt;贴吧\u0026lt;/a\u0026gt; \u0026lt;noscript\u0026gt; \u0026lt;a href=http://www.baidu.com/bdorz/login.gif?login\u0026amp;amp;tpl=mn\u0026amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb\u0026gt;登录\u0026lt;/a\u0026gt; \u0026lt;/noscript\u0026gt; \u0026lt;script\u0026gt;document.write(\u0026#39;\u0026lt;a href=\u0026#34;http://www.baidu.com/bdorz/login.gif?login\u0026amp;tpl=mn\u0026amp;u=\u0026#39;+ encodeURIComponent(window.location.href+ (window.location.search === \u0026#34;\u0026#34; ? \u0026#34;?\u0026#34; : \u0026#34;\u0026amp;\u0026#34;)+ \u0026#34;bdorz_come=1\u0026#34;)+ \u0026#39;\u0026#34; name=\u0026#34;tj_login\u0026#34; class=\u0026#34;lb\u0026#34;\u0026gt;登录\u0026lt;/a\u0026gt;\u0026#39;);\u0026lt;/script\u0026gt; \u0026lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style=\u0026#34;display: block;\u0026#34;\u0026gt;更多产品\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=ftCon\u0026gt; \u0026lt;div id=ftConw\u0026gt; \u0026lt;p id=lh\u0026gt; \u0026lt;a href=http://home.baidu.com\u0026gt;关于百度\u0026lt;/a\u0026gt; \u0026lt;a href=http://ir.baidu.com\u0026gt;About Baidu\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p id=cp\u0026gt;\u0026amp;copy;2017\u0026amp;nbsp;Baidu\u0026amp;nbsp;\u0026lt;a href=http://www.baidu.com/duty/\u0026gt;使用百度前必读\u0026lt;/a\u0026gt;\u0026amp;nbsp; \u0026lt;a href=http://jianyi.baidu.com/ class=cp-feedback\u0026gt;意见反馈\u0026lt;/a\u0026gt;\u0026amp;nbsp;京ICP证030173号\u0026amp;nbsp; \u0026lt;img src=//www.baidu.com/img/gs.gif\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; * Connection #0 to host 127.0.0.1 left intact 同理可以访问 bing.com：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 $ curl -s -o /dev/null -vvv -H \u0026#39;Host: bing.com\u0026#39; localhost:15001 ... * Connected to 127.0.0.1 (127.0.0.1) port 15001 (#0) \u0026gt; GET / HTTP/1.1 \u0026gt; Host: bing.com \u0026gt; User-Agent: curl/7.54.0 \u0026gt; Accept: */* \u0026gt; \u0026lt; HTTP/1.1 200 OK \u0026lt; cache-control: private, max-age=0 \u0026lt; content-length: 112683 \u0026lt; content-type: text/html; charset=utf-8 \u0026lt; p3p: CP=\u0026#34;NON UNI COM NAV STA LOC CURa DEVa PSAa PSDa OUR IND\u0026#34; \u0026lt; set-cookie: SRCHD=AF=NOFORM; domain=.bing.com; expires=Tue, 03-May-2022 13:08:55 GMT; path=/ \u0026lt; set-cookie: SRCHUID=V=2\u0026amp;GUID=D8E47780338144C587A3F6EC1D831373\u0026amp;dmnchg=1; domain=.bing.com; expires=Tue, 03-May-2022 13:08:55 GMT; path=/ \u0026lt; set-cookie: SRCHUSR=DOB=20200503; domain=.bing.com; expires=Tue, 03-May-2022 13:08:55 GMT; path=/ \u0026lt; set-cookie: _SS=SID=3E6E525A1E406DCF27B15CE51F6E6C28; domain=.bing.com; path=/ \u0026lt; x-msedge-ref: Ref A: BB80A686B64D4DCAB5713DB6ADF294C8 Ref B: BJ1EDGE0217 Ref C: 2020-05-03T13:08:55Z \u0026lt; set-cookie: _EDGE_S=F=1\u0026amp;SID=3E6E525A1E406DCF27B15CE51F6E6C28; path=/; httponly; domain=bing.com \u0026lt; set-cookie: _EDGE_V=1; path=/; httponly; expires=Fri, 28-May-2021 13:08:55 GMT; domain=bing.com \u0026lt; set-cookie: MUID=20CC7B7828C26CF93BE175C729EC6D8A; samesite=none; path=/; secure; expires=Fri, 28-May-2021 13:08:55 GMT; domain=bing.com \u0026lt; set-cookie: MUIDB=20CC7B7828C26CF93BE175C729EC6D8A; path=/; httponly; expires=Fri, 28-May-2021 13:08:55 GMT \u0026lt; date: Sun, 03 May 2020 13:08:53 GMT \u0026lt; x-envoy-upstream-service-time: 151 \u0026lt; server: envoy \u0026lt; { [6069 bytes data] 查看 Envoy 的日志：\n1 2 [2020-05-03T13:10:39.968Z] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - 0 2381 50 49 \u0026#34;-\u0026#34; \u0026#34;curl/7.54.0\u0026#34; \u0026#34;201f8fe4-3446-4063-b6f2-b6289100529a\u0026#34; \u0026#34;www.baidu.com\u0026#34; \u0026#34;198.18.5.232:80\u0026#34; [2020-05-03T13:10:47.501Z] \u0026#34;GET / HTTP/1.1\u0026#34; 200 - 0 112348 263 160 \u0026#34;-\u0026#34; \u0026#34;curl/7.54.0\u0026#34; \u0026#34;d291ec6b-3669-426a-8f79-9be696d8c97a\u0026#34; \u0026#34;cn.bing.com\u0026#34; \u0026#34;198.18.10.118:80\u0026#34; 可以看到这两个不同的请求都得到了正确响应。\n参考资料 浅谈 Service Mesh 体系中的 Envoy ","description":"使用 Envoy 作为边缘代理","id":5,"section":"docs","tags":null,"title":"快速开始","uri":"https://fuckcloudnative.io/envoy-handbook/docs/gettingstarted/quick-start/"},{"content":"Envoy 架构 Envoy 的架构如图所示：\nEnvoy 接收到请求后，会先走 FilterChain，通过各种 L3/L4/L7 Filter 对请求进行微处理，然后再路由到指定的集群，并通过负载均衡获取一个目标地址，最后再转发出去。\n其中每一个环节可以静态配置，也可以动态服务发现，也就是所谓的 xDS。这里的 x 是一个代词，类似云计算里的 XaaS 可以指代 IaaS、PaaS、SaaS 等。\n配置结构 Envoy 的整体配置结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \u0026#34;node\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;static_resources\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;dynamic_resources\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;cluster_manager\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;hds_config\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;flags_path\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;stats_sinks\u0026#34;: [], \u0026#34;stats_config\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;stats_flush_interval\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;watchdog\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;tracing\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;runtime\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;layered_runtime\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;admin\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;overload_manager\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;enable_dispatcher_stats\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;header_prefix\u0026#34;: \u0026#34;...\u0026#34;, \u0026#34;stats_server_version_override\u0026#34;: \u0026#34;{...}\u0026#34;, \u0026#34;use_tcp_for_dns_lookups\u0026#34;: \u0026#34;...\u0026#34; } node : 节点标识，配置的是 Envoy 的标记信息，management server 利用它来标识不同的 Envoy 实例。参考 core.Node static_resources : 定义静态配置，是 Envoy 核心工作需要的资源，由 Listener、Cluster 和 Secret 三部分组成。参考 config.bootstrap.v2.Bootstrap.StaticResources dynamic_resources : 定义动态配置，通过 xDS 来获取配置。可以同时配置动态和静态。 cluster_manager : 管理所有的上游集群。它封装了连接后端服务的操作，当 Filter 认为可以建立连接时，便调用 cluster_manager 的 API 来建立连接。cluster_manager 负责处理负载均衡、健康检查等细节。 hds_config : 健康检查服务发现动态配置。 stats_sinks : 状态输出插件。可以将状态数据输出到多种采集系统中。一般通过 Envoy 的管理接口 /stats/prometheus 就可以获取 Prometheus 格式的指标，这里的配置应该是为了支持其他的监控系统。 stats_config : 状态指标配置。 stats_flush_interval : 状态指标刷新时间。 watchdog : 看门狗配置。Envoy 内置了一个看门狗系统，可以在 Envoy 没有响应时增加相应的计数器，并根据计数来决定是否关闭 Envoy 服务。 tracing : 分布式追踪相关配置。 runtime : 运行时状态配置（已弃用）。 layered_runtime : 层级化的运行时状态配置。可以静态配置，也可以通过 RTDS 动态加载配置。 admin : 管理接口。 overload_manager : 过载过滤器。 header_prefix : Header 字段前缀修改。例如，如果将该字段设为 X-Foo，那么 Header 中的 x-envoy-retry-on 将被会变成 x-foo-retry-on。 use_tcp_for_dns_lookups : 强制使用 TCP 查询 DNS。可以在 Cluster 的配置中覆盖此配置。 过滤器 Envoy 进程中运行着一系列 Inbound/Outbound 监听器（Listener），Inbound 代理入站流量，Outbound 代理出站流量。Listener 的核心就是过滤器链（FilterChain），链中每个过滤器都能够控制流量的处理流程。过滤器链中的过滤器分为两个类别：\n网络过滤器（Network Filters）: 工作在 L3/L4，是 Envoy 网络连接处理的核心，处理的是原始字节，分为 Read、Write 和 Read/Write 三类。 HTTP 过滤器（HTTP Filters）: 工作在 L7，由特殊的网络过滤器 HTTP connection manager 管理，专门处理 HTTP1/HTTP2/gRPC 请求。它将原始字节转换成 HTTP 格式，从而可以对 HTTP 协议进行精确控制。 除了 HTTP connection manager 之外，还有一种特别的网络过滤器叫 Thrift Proxy。Thrift 是一套包含序列化功能和支持服务通信的 RPC 框架，详情参考维基百科。Thrift Proxy 管理了两个 Filter：Router 和 Rate Limit。\n除了过滤器链之外，还有一种过滤器叫监听器过滤器（Listener Filters），它会在过滤器链之前执行，用于操纵连接的元数据。这样做的目的是，无需更改 Envoy 的核心代码就可以方便地集成更多功能。例如，当监听的地址协议是 UDP 时，就可以指定 UDP 监听器过滤器。\n根据上面的分类，Envoy 过滤器的架构如下图所示：\n","description":"本章节描述了 Envoy 的整体架构、Filter 的架构以及配置结构","id":6,"section":"docs","tags":null,"title":"Envoy 架构与配置结构","uri":"https://fuckcloudnative.io/envoy-handbook/docs/gettingstarted/architecture/"},{"content":"在云环境下，技术栈可以是多种多样的。那么如何能够将这些异构的服务组件串联起来，成为了服务治理的一个重大课题。而 Sidecar 模式为服务治理，提供了一种解决方案。\n问题背景 大部分应用和服务都需要实现额外的服务治理功能，这些功能可以作为单独的组件或服务而存在。如果将这些功能集成到业务应用中，就会与业务应用运行在同一个进程中，从而可以有效地共享资源。从另一方面来看，这也意味着服务治理组件与业务应用之间的隔离性很弱，一旦其中一个组件出现故障，可能会影响其他组件甚至整个应用程序。除此之外，服务治理组件需要使用与父应用程序相同的技术栈来实现，因此它们之间有密切的相互依赖性。\n解决方案 上述问题的解决方案是，将服务治理功能从应用本身剥离出来作为单独进程，与主应用程序共同放在一台主机（Host）中，但会将它们部署在各自的进程或容器中。这种方式也被称为 Sidecar（边车）模式。\n下图展示了服务治理功能与主应用程序的部署关系图。\n该模式允许我们向应用无侵入添加多种功能，避免了为满足第三方组件需求而向应用添加额外的配置代码。\nSidecar 模式 在软件架构中，Sidecar 附加到主应用，或者叫父应用上，以扩展/增强功能特性，同时 Sidecar 与主应用是松耦合的。这就像是如下图所示的边三轮摩托车那样，将边车（Sidecar）安装在一辆摩托车上，就变成了边三轮摩托车。每辆边三轮摩托车都有自己的边车。类似同样的方式，Sidecar 服务共享其父应用程序的主机。对于应用程序的每个实例，边车的实例被部署并与其一起托管。\n使用 Sidecar 模式的好处有很多：\n通过将服务治理相关功能抽象到不同的层来降低微服务的代码复杂性 在运行时环境和编程语言方面，Sidecar 独立于其主要应用程序，不需要为每个微服务编写服务治理功能的代码，减少了微服务架构中的代码重复。 Sidecar 可以访问与主应用程序相同的资源。例如，Sidecar 可以监视 Sidecar 本身和主应用程序使用的系统资源。 由于它靠近主应用程序，因此在它们之间进行通信时没有明显的延迟。 降低了应用与底层平台的耦合度。 Envoy Envoy 是为云原生应用设计的代理，可以在服务旁运行，以平台无关的方式提供必要的特性，所有到服务的流量都通过 Envoy 代理，这里 Envoy 扮演的就是 Sidecar 的角色。\n总的来说，在从一体化架构向微服务架构的转型让我们可以相对独立、大规模地部署应用，而在容器环境中，Sidecar 模式可以很好地兼容，帮助我们降低微服务架构复杂性，更好地实现服务发现、流量管理、负载均衡、路由。\n参考资料 了解Sidecar模式 Sidecar模式：下一代微服务架构的关键 ","description":"","id":7,"section":"docs","tags":null,"title":"Sidecar 模式","uri":"https://fuckcloudnative.io/envoy-handbook/docs/overview/sidecar/"}]